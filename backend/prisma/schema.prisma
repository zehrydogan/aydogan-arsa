// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User management with role-based access
model User {
  id          String   @id @default(cuid())
  email       String   @unique
  password    String
  firstName   String
  lastName    String
  phone       String?
  avatar      String?
  role        UserRole @default(VISITOR)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  properties       Property[]
  savedSearches    SavedSearch[]
  favorites        Favorite[]
  contactRequests  ContactRequest[] @relation("VisitorContacts")
  sentMessages     Message[] @relation("MessageSender")
  receivedMessages Message[] @relation("MessageReceiver")
  conversations    ConversationParticipant[]
  
  @@map("users")
}

enum UserRole {
  ADMIN
  OWNER
  VISITOR
}

// Location hierarchy for geographic organization
model Location {
  id       String       @id @default(cuid())
  name     String
  type     LocationType
  parentId String?
  parent   Location?    @relation("LocationHierarchy", fields: [parentId], references: [id])
  children Location[]   @relation("LocationHierarchy")
  
  // Relations
  properties Property[]
  
  @@map("locations")
}

enum LocationType {
  CITY
  DISTRICT
  NEIGHBORHOOD
}

// Core property model with geographic data
model Property {
  id          String           @id @default(cuid())
  title       String
  description String
  price       Decimal          @db.Decimal(12, 2)
  currency    String           @default("USD")
  
  // Geographic data
  latitude    Float
  longitude   Float
  address     String
  locationId  String
  location    Location         @relation(fields: [locationId], references: [id])
  
  // Property details stored as JSONB for flexibility
  // Arsa detayları: area (m²), adaParsel, imarDurumu, tapuDurumu, gabari, katSayisi, emsal
  details     Json
  
  category    PropertyCategory
  status      PropertyStatus   @default(DRAFT)
  
  // Ownership
  ownerId     String
  owner       User             @relation(fields: [ownerId], references: [id])
  
  // Timestamps
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  publishedAt DateTime?
  
  // Relations
  images         PropertyImage[]
  features       PropertyFeature[]
  contactRequests ContactRequest[]
  favorites      Favorite[]
  conversations  Conversation[]
  
  // PostGIS spatial index
  @@index([latitude, longitude])
  @@map("properties")
}

enum PropertyCategory {
  IMARLIARSA      // İmarlı Arsa
  TARLA           // Tarla
  BAHCE           // Bahçe
  ZEYTINLIK       // Zeytinlik
  BAGLIK          // Bağlık
  SANAYI          // Sanayi Arsası
  KONUT           // Konut Arsası
  TICARI          // Ticari Arsa
}

enum PropertyStatus {
  DRAFT
  PUBLISHED
  SOLD
  INACTIVE
}

// Property images with cloud storage integration
model PropertyImage {
  id         String   @id @default(cuid())
  propertyId String
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  
  url        String
  publicId   String   // For Cloudinary or S3 key
  alt        String?
  order      Int      @default(0)
  
  createdAt  DateTime @default(now())
  
  @@map("property_images")
}

// Property features with many-to-many relationship
model Feature {
  id          String            @id @default(cuid())
  name        String            @unique
  category    String            // interior, exterior, building
  icon        String?
  
  properties  PropertyFeature[]
  
  @@map("features")
}

model PropertyFeature {
  propertyId String
  featureId  String
  
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  feature    Feature  @relation(fields: [featureId], references: [id], onDelete: Cascade)
  
  @@id([propertyId, featureId])
  @@map("property_features")
}

// Contact system for visitor-owner communication
model ContactRequest {
  id         String   @id @default(cuid())
  subject    String
  message    String
  
  // Visitor information
  visitorId  String?
  visitor    User?    @relation("VisitorContacts", fields: [visitorId], references: [id])
  
  // Guest contact (for non-registered visitors)
  guestName  String?
  guestEmail String?
  guestPhone String?
  
  propertyId String
  property   Property @relation(fields: [propertyId], references: [id])
  
  status     ContactStatus @default(PENDING)
  isRead     Boolean       @default(false)
  createdAt  DateTime      @default(now())
  
  @@map("contact_requests")
}

enum ContactStatus {
  PENDING
  RESPONDED
  CLOSED
}

// Real-time messaging system
model Conversation {
  id         String   @id @default(cuid())
  propertyId String
  property   Property @relation(fields: [propertyId], references: [id])
  
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  
  // Relations
  participants ConversationParticipant[]
  messages     Message[]
  
  @@map("conversations")
}

model ConversationParticipant {
  id             String       @id @default(cuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  userId         String
  user           User         @relation(fields: [userId], references: [id])
  
  joinedAt       DateTime     @default(now())
  lastReadAt     DateTime?
  
  @@unique([conversationId, userId])
  @@map("conversation_participants")
}

model Message {
  id             String       @id @default(cuid())
  content        String
  
  senderId       String
  sender         User         @relation("MessageSender", fields: [senderId], references: [id])
  
  receiverId     String
  receiver       User         @relation("MessageReceiver", fields: [receiverId], references: [id])
  
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  isRead         Boolean      @default(false)
  createdAt      DateTime     @default(now())
  
  @@map("messages")
}

// User preferences and saved searches
model SavedSearch {
  id        String   @id @default(cuid())
  name      String
  filters   Json     // Search criteria as JSON
  
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("saved_searches")
}

model Favorite {
  userId     String
  propertyId String
  
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  
  createdAt  DateTime @default(now())
  
  @@id([userId, propertyId])
  @@map("favorites")
}